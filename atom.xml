<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>竹林幽居</title>
  
  <subtitle>曲径通幽处，禅房花木深...</subtitle>
  <link href="http://wyfboy.github.io/atom.xml" rel="self"/>
  
  <link href="http://wyfboy.github.io/"/>
  <updated>2021-04-02T08:28:51.101Z</updated>
  <id>http://wyfboy.github.io/</id>
  
  <author>
    <name>YunFei Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git操作命令</title>
    <link href="http://wyfboy.github.io/2021/04/01/git%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://wyfboy.github.io/2021/04/01/git%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</id>
    <published>2021-04-01T05:49:00.000Z</published>
    <updated>2021-04-02T08:28:51.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git基本概念"><a href="#Git基本概念" class="headerlink" title="Git基本概念"></a>Git基本概念</h2><h3 id="集中式和分布式的版本控制系统的比较"><a href="#集中式和分布式的版本控制系统的比较" class="headerlink" title="集中式和分布式的版本控制系统的比较"></a>集中式和分布式的版本控制系统的比较</h3><ul><li>集中式的版本控制（CVCS），中央服务器作为协同工作的版本控制系统，可以让在不同系统上的开发者协同工作。但是若中央服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</li></ul><p>​                                        <img data-src="image-20210402144454484.png" alt="image-20210402144454484" style="zoom:50%;">        </p><ul><li>分布式版本控制系统（DVCS），客户端并不只是提取到最新版本的文件快照，而是把代码仓库完整的镜像下来，包括完整的历史记录。这么一来，任何一处协同工作的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</li></ul><img data-src="image-20210402144032267.png" style="zoom:50%;"><h3 id="Git基本概念-1"><a href="#Git基本概念-1" class="headerlink" title="Git基本概念"></a>Git基本概念</h3><ul><li><strong>工作区</strong>：在电脑中能看到的目录。</li><li><strong>暂存区</strong>：一般放在<code>.git</code>目录下的index文件（.git/index）中。</li><li><strong>版本库</strong>：工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</li></ul><p><img data-src="image-20210401134958468.png" alt="image-20210401134958468"></p><ul><li>“index”标记的为暂存区，“master”标记的为master分支所代表的目录树</li><li>当对工作区修改（或新增）的文件执行<code>git add</code>命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新对象中，而该对象的ID被记录在暂存区的文件索引中。</li><li>当执行提交操作<code>git commit</code>时，暂存区的目录树写到版本库中，master分支会做相应的更新。即master指向的目录树就是提交时暂存区的目录树。</li><li>当执行<code>git reset HEAD</code>命令时，暂存区的目录树会被重写，被master分支指向的目录树所替代，但是工作区不受影响。</li><li>当执行<code>git rm --cached &lt;file&gt;</code>命令时，会直接从暂存区删除文件，工作区则不会做出改变。</li><li>当执行 <code>git checkout .</code>或者 <code>git checkout -- &lt;file&gt;</code>命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</li><li>当执行 <code>git checkout HEAD .</code>或 <code>git checkout HEAD &lt;file&gt;</code>命令时，会用HEAD指向的master分支中的全部或者部分文件替换暂存区和工作区中的文件。这个命令也是极具危险的，因为不仅会清除工作区的未提交的改动，也会清除暂存区中未提交的改动。</li></ul><h2 id="Git创建仓库"><a href="#Git创建仓库" class="headerlink" title="Git创建仓库"></a>Git创建仓库</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>使用当前目录作为Git仓库，我们只需使它初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>该命令执行完后会在当前目录生成一个.git目录。</p><p>使用我们指定目录作为Git仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init newrepo</span><br></pre></td></tr></table></figure><p>初始化后，会在newrepo目录下出现一个名为.git的目录，所有Git需要的数据和资源都存放在这个目录中。如果当前目录下有几个文件想要纳入版本控制，需要先用<code>git add</code>命令告诉Git开始对这些文件进行跟踪，然后提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &quot;初始化项目版本&quot;</span><br></pre></td></tr></table></figure><p>以上命令将目录下以.c结尾及README文件提交到仓库中。</p><hr><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>克隆仓库的命令格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt;</span><br></pre></td></tr></table></figure><p>克隆到指定的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure><p>可以使用不同的协议克隆，其中最常见的是ssh，因为速度较快，还可以配置公钥免输入密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:fsliurujie&#x2F;test.git         --SSH协议</span><br><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;fsliurujie&#x2F;test.git          --GIT协议</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;fsliurujie&#x2F;test.git      --HTTPS协议</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>使用<code>git config</code>命令配置git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">credential.helper&#x3D;osxkeychain</span><br><span class="line">core.repositoryformatversion&#x3D;0</span><br><span class="line">core.filemode&#x3D;true</span><br><span class="line">core.bare&#x3D;false</span><br><span class="line">core.logallrefupdates&#x3D;true</span><br><span class="line">core.ignorecase&#x3D;true</span><br><span class="line">core.precomposeunicode&#x3D;true</span><br></pre></td></tr></table></figure><p>编辑git配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config -e  #针对当前仓库</span><br><span class="line">或者：</span><br><span class="line">$ git config -e --global  #针对系统上所有仓库</span><br></pre></td></tr></table></figure><p>设置提交代码时的用户信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;wyfboy&quot;</span><br><span class="line">$ git config --global user.email test@wyfboy.com</span><br></pre></td></tr></table></figure><p>如果去掉**–global**参数，只会对当前仓库有效。</p><hr><h2 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h2><p><img data-src="image-20210402105859872.png" alt="image-20210402105859872"></p><ul><li>workspace：工作区</li><li>staging area：暂存区/缓存区</li><li>local repository：版本库或本地仓库</li><li>remote repository：远程仓库</li></ul><h3 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h3><p><img data-src="image-20210402110153681.png" alt="image-20210402110153681"></p><h4 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h4><p><img data-src="image-20210402110222956.png" alt="image-20210402110222956"></p><h4 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h4><p><img data-src="image-20210402110241186.png" alt="image-20210402110241186"></p><h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><p>创建分支命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch (branchName)</span><br></pre></td></tr></table></figure><p>切换分支命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout (branchName)</span><br></pre></td></tr></table></figure><p>切换分支时，Git会用该分支的最后提交的快照替换你的工作区目录的内容，所以多个分支不需要多个目录。</p><hr><p>列出分支命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>合并分支命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branchName&gt;</span><br></pre></td></tr></table></figure><p>一旦某分支有了独立的内容，可以使用以上命令将任何分支合并到当前主分支中，合并完后就可以删除分支了。 </p><hr><p>删除分支命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d (branchName)</span><br></pre></td></tr></table></figure><p>合并冲突：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">UU runoob.php</span><br><span class="line">$ git add runoob.php</span><br><span class="line">$ git status -s</span><br><span class="line">M  runoob.php</span><br><span class="line">$ git commit</span><br><span class="line">[master 88afe0e] Merge branch &#39;change_site&#39;</span><br></pre></td></tr></table></figure><h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><p>以下操作把README.md添加版本控制，这样在每个分支上都会看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">64845@DESKTOP-LIFUUP9 MINGW64 &#x2F;e&#x2F;wyfboy (master)</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">64845@DESKTOP-LIFUUP9 MINGW64 &#x2F;e&#x2F;wyfboy (master)</span><br><span class="line">$ ls</span><br><span class="line">64845@DESKTOP-LIFUUP9 MINGW64 &#x2F;e&#x2F;wyfboy (master)</span><br><span class="line">$ touch README.md</span><br><span class="line">64845@DESKTOP-LIFUUP9 MINGW64 &#x2F;e&#x2F;wyfboy (master)</span><br><span class="line">$ git add README.md</span><br><span class="line">64845@DESKTOP-LIFUUP9 MINGW64 &#x2F;e&#x2F;wyfboy (master)</span><br><span class="line">$ git commit -m &quot;第一次版本提交&quot;</span><br><span class="line">[master 31185f1] 第一次版本提交</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README.md</span><br><span class="line">64845@DESKTOP-LIFUUP9 MINGW64 &#x2F;e&#x2F;wyfboy (master)</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line">64845@DESKTOP-LIFUUP9 MINGW64 &#x2F;e&#x2F;wyfboy (wyf)</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><p>以下操作将add进暂存区的文件删除：</p><p><img data-src="image-20210402145541386.png" alt="image-20210402145541386"></p><p>在wyf分支上移除了一个文件test.txt并添加了一个文件runoob.php，但我们切换回master分支，发现test.txt又回来了，并且新增的runoob.php不在主分支上。</p><p>这样使用分支将工作切分开来，从而让我们在不同的开发环境中做事，并来回切换。</p><p><img data-src="image-20210402152823094.png" alt="image-20210402152823094"></p><p>将wyf分支合并到主分支上去，这样wyf分支中的runoob.php将会到master分支上,并且test.txt被删除。合并后，wyf分支就可以删除了：</p><p><img data-src="image-20210402153933923.png" alt="image-20210402153933923"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Git基本概念&quot;&gt;&lt;a href=&quot;#Git基本概念&quot; class=&quot;headerlink&quot; title=&quot;Git基本概念&quot;&gt;&lt;/a&gt;Git基本概念&lt;/h2&gt;&lt;h3 id=&quot;集中式和分布式的版本控制系统的比较&quot;&gt;&lt;a href=&quot;#集中式和分布式的版本控制系统的比</summary>
      
    
    
    
    <category term="Git" scheme="http://wyfboy.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="http://wyfboy.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>github-hexo图片无法显示</title>
    <link href="http://wyfboy.github.io/2021/04/01/github-hexo%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/"/>
    <id>http://wyfboy.github.io/2021/04/01/github-hexo%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</id>
    <published>2021-04-01T03:46:44.000Z</published>
    <updated>2021-04-01T04:01:12.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="config-yml文件修改"><a href="#config-yml文件修改" class="headerlink" title="config.yml文件修改"></a>config.yml文件修改</h3><p>将 <code>post_asset_folder: false</code> 修改为 <code>post_asset_folder: true</code></p><p>在新建博文时可以同时在_posts文件夹中创建一个同名文件夹，可以用来存放这个.md博文的图片，易于管理。</p><span id="more"></span><h3 id="Typora偏好设置"><a href="#Typora偏好设置" class="headerlink" title="Typora偏好设置"></a>Typora偏好设置</h3><p><img data-src="Typora%E5%81%8F%E5%A5%BD%E8%AE%BE%E7%BD%AE.png"></p><p>插入同名文件夹里的图片可以看到路径是相对路径：</p><p><img data-src="%E8%B7%AF%E5%BE%84%E6%98%BE%E7%A4%BA.png"></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p><strong>方式一</strong>：<code>npm install https://github.com/7ym0n/hexo-asset-image --save</code>不幸的是我安装后出现了问题。</p><p><strong>另一种迂回方式</strong>：把此文件夹<em>\node_modules\hexo-asset-image</em>删除后，换种方式安装<code>   npm install https://github.com/CodeFalling/hexo-asset-image --save</code>，然后把该插件文件夹里的<em>index.js</em>替换成如下：</p><pre><code>&#39;use strict&#39;;var cheerio = require(&#39;cheerio&#39;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123;return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&#39;.&#39;);hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;var config = hexo.config;if(config.post_asset_folder)&#123;    var link = data.permalink;if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)    var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;else    var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.var endPos = link.lastIndexOf(&#39;/&#39;) + 1;link = link.substring(beginPos, endPos);var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];for(var i = 0; i &lt; toprocess.length; i++)&#123;    var key = toprocess[i];var $ = cheerio.load(data[key], &#123;ignoreWhitespace: false,xmlMode: false,lowerCaseTags: false,decodeEntities: false&#125;);$(&#39;img&#39;).each(function()&#123;if ($(this).attr(&#39;src&#39;))&#123;    // For windows style path, we replace &#39;\&#39; to &#39;/&#39;.    var src = $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;/&#39;);    if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;        !/^\s*\//.test(src)) &#123;        // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.        // In addition, to support multi-level local directory.        var linkArray = link.split(&#39;/&#39;).filter(function(elem)&#123;        return elem != &#39;&#39;;        &#125;);        var srcArray = src.split(&#39;/&#39;).filter(function(elem)&#123;        return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;        &#125;);        if(srcArray.length &gt; 1)        srcArray.shift();        src = srcArray.join(&#39;/&#39;);        $(this).attr(&#39;src&#39;, config.root + link + src);        console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);    &#125;&#125;else&#123;    console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);    console.info&amp;&amp;console.info($(this));&#125;&#125;);data[key] = $.html();&#125;&#125;&#125;);</code></pre><p>再次生成和部署后，成功显示图片。（本地预览和部署到github上后都能正常显示）</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;config-yml文件修改&quot;&gt;&lt;a href=&quot;#config-yml文件修改&quot; class=&quot;headerlink&quot; title=&quot;config.yml文件修改&quot;&gt;&lt;/a&gt;config.yml文件修改&lt;/h3&gt;&lt;p&gt;将 &lt;code&gt;post_asset_folder: false&lt;/code&gt; 修改为 &lt;code&gt;post_asset_folder: true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在新建博文时可以同时在_posts文件夹中创建一个同名文件夹，可以用来存放这个.md博文的图片，易于管理。&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="http://wyfboy.github.io/categories/hexo/"/>
    
    
    <category term="hexo图片无法显示" scheme="http://wyfboy.github.io/tags/hexo%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/"/>
    
  </entry>
  
  <entry>
    <title>Configuration注解用法</title>
    <link href="http://wyfboy.github.io/2021/03/27/Configuration%E6%B3%A8%E8%A7%A3%E7%94%A8%E6%B3%95/"/>
    <id>http://wyfboy.github.io/2021/03/27/Configuration%E6%B3%A8%E8%A7%A3%E7%94%A8%E6%B3%95/</id>
    <published>2021-03-27T08:44:06.000Z</published>
    <updated>2021-03-27T08:47:02.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Configuration使用示例"><a href="#Configuration使用示例" class="headerlink" title="Configuration使用示例"></a>Configuration使用示例</h2><p>1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的</p><p>2、配置类本身也是组件</p><p>3、proxyBeanMethods：代理bean的方法</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Full(proxyBeanMethods = <span class="keyword">true</span>)、【保证每个<span class="meta">@Bean</span>方法被调用多少次返回的组件都是单实例的】</span><br><span class="line">Lite(proxyBeanMethods = <span class="keyword">false</span>)【每个<span class="meta">@Bean</span>方法被调用多少次返回的组件都是新创建的】</span><br></pre></td></tr></table></figure><p><strong>组件依赖必须使用Full模式默认。其他默认是否Lite模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">   User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">   <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">   zhangsan.setPet(tomcatPet());</span><br><span class="line">   <span class="keyword">return</span> zhangsan;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;tom&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Configuration测试代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">相当于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">    String[] names = run.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、从容器中获取组件</span></span><br><span class="line"></span><br><span class="line">    Pet tom01 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">    Pet tom02 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;组件：&quot;</span>+(tom01 == tom02));</span><br><span class="line">    <span class="comment">//4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892</span></span><br><span class="line">    MyConfig bean = run.getBean(MyConfig.class);</span><br><span class="line">    System.out.println(bean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。</span></span><br><span class="line">    <span class="comment">//保持组件单实例</span></span><br><span class="line">    User user = bean.user01();</span><br><span class="line">    User user1 = bean.user01();</span><br><span class="line">    System.out.println(user == user1);</span><br><span class="line">    User user01 = run.getBean(<span class="string">&quot;user01&quot;</span>, User.class);</span><br><span class="line">    Pet tom = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;用户的宠物：&quot;</span>+(user01.getPet() == tom));</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Configuration使用示例&quot;&gt;&lt;a href=&quot;#Configuration使用示例&quot; class=&quot;headerlink&quot; title=&quot;Configuration使用示例&quot;&gt;&lt;/a&gt;Configuration使用示例&lt;/h2&gt;&lt;p&gt;1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的&lt;/p&gt;
&lt;p&gt;2、配置类本身也是组件&lt;/p&gt;
&lt;p&gt;3、proxyBeanMethods：代理bean的方法&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="http://wyfboy.github.io/categories/SpringBoot/"/>
    
    
    <category term="注解" scheme="http://wyfboy.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>AOP与OOP的比较</title>
    <link href="http://wyfboy.github.io/2021/03/27/AOP/"/>
    <id>http://wyfboy.github.io/2021/03/27/AOP/</id>
    <published>2021-03-27T08:37:07.000Z</published>
    <updated>2021-03-27T09:55:44.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AOP面向切面，为什么要面向切面？哪些操作需要AOP编程？"><a href="#AOP面向切面，为什么要面向切面？哪些操作需要AOP编程？" class="headerlink" title="AOP面向切面，为什么要面向切面？哪些操作需要AOP编程？"></a>AOP面向切面，为什么要面向切面？哪些操作需要AOP编程？</h2><p>​        Aop主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合的隔离效果。</p><span id="more"></span><p>​        比如我们最常见的就是日志记录了，举个例子，我们现在提供一个查询学生信息的服务，但是我们希望记录有谁进行了这个查询。如果按照传统的OOP的实现的话，那我们实现了一个查询学生信息的服务接口(StudentInfoService)和其实现 类 （StudentInfoServiceImpl.java），同时为了要进行记录的话，那我们在实现类(StudentInfoServiceImpl.java)中要添加其实现记录的过程<br>​        当要实现的服务有多个时，那就要在每个实现类都添加这些记录过程，这就非常繁琐，而且每个实现类都与记录服务日志的行为紧耦合，违反了面向对象的规则。</p><p><strong>一般oop模式：</strong></p><p><img data-src="oop.png"></p><p>每一个模块都跟日志、事务这些功能交织在一起，无法分离，每当修改日志的形式的时候，需要非常多的代码。</p><p><strong>aop模式：</strong></p><p>​                                                           <img data-src="aop.png"></p><p>输入的数据先经过日志、事务等控制模块，然后再流向实际的业务模块，而日志、事务这些控制模块看起来就像一道切面，切在数据流的中间</p><p><strong>优势：</strong></p><ol><li>解耦</li><li>重复利用代码</li><li>便于装卸</li></ol><h2 id="Configuration使用示例"><a href="#Configuration使用示例" class="headerlink" title="Configuration使用示例"></a>Configuration使用示例</h2><p>1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的</p><p>2、配置类本身也是组件</p><p>3、proxyBeanMethods：代理bean的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Full(proxyBeanMethods = <span class="keyword">true</span>)、【保证每个<span class="meta">@Bean</span>方法被调用多少次返回的组件都是单实例的】</span><br><span class="line">Lite(proxyBeanMethods = <span class="keyword">false</span>)【每个<span class="meta">@Bean</span>方法被调用多少次返回的组件都是新创建的】</span><br></pre></td></tr></table></figure><p><strong>组件依赖必须使用Full模式默认。其他默认是否Lite模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">   User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">   <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">   zhangsan.setPet(tomcatPet());</span><br><span class="line">   <span class="keyword">return</span> zhangsan;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;tom&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Configuration测试代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">相当于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">    String[] names = run.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、从容器中获取组件</span></span><br><span class="line"></span><br><span class="line">    Pet tom01 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">    Pet tom02 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;组件：&quot;</span>+(tom01 == tom02));</span><br><span class="line">    <span class="comment">//4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892</span></span><br><span class="line">    MyConfig bean = run.getBean(MyConfig.class);</span><br><span class="line">    System.out.println(bean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。</span></span><br><span class="line">    <span class="comment">//保持组件单实例</span></span><br><span class="line">    User user = bean.user01();</span><br><span class="line">    User user1 = bean.user01();</span><br><span class="line">    System.out.println(user == user1);</span><br><span class="line">    User user01 = run.getBean(<span class="string">&quot;user01&quot;</span>, User.class);</span><br><span class="line">    Pet tom = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;用户的宠物：&quot;</span>+(user01.getPet() == tom));</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;AOP面向切面，为什么要面向切面？哪些操作需要AOP编程？&quot;&gt;&lt;a href=&quot;#AOP面向切面，为什么要面向切面？哪些操作需要AOP编程？&quot; class=&quot;headerlink&quot; title=&quot;AOP面向切面，为什么要面向切面？哪些操作需要AOP编程？&quot;&gt;&lt;/a&gt;AOP面向切面，为什么要面向切面？哪些操作需要AOP编程？&lt;/h2&gt;&lt;p&gt;​        Aop主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合的隔离效果。&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="http://wyfboy.github.io/categories/SpringBoot/"/>
    
    
    <category term="AOP" scheme="http://wyfboy.github.io/tags/AOP/"/>
    
    <category term="注解" scheme="http://wyfboy.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记</title>
    <link href="http://wyfboy.github.io/2021/03/23/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://wyfboy.github.io/2021/03/23/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-23T08:18:33.000Z</published>
    <updated>2021-03-27T08:46:33.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单功能分析"><a href="#简单功能分析" class="headerlink" title="简单功能分析"></a>简单功能分析</h1><h2 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h2><h3 id="静态资源目录"><a href="#静态资源目录" class="headerlink" title="静态资源目录"></a>静态资源目录</h3><p>只要静态资源放在类路径下：called <strong>/static</strong>(or <strong>/public</strong> or <strong>/META-INF/resources</strong> or <strong>/resources</strong>)</p><p>访问：当前项目根路径/+静态资源名</p><p>原理：静态映射/**，请求进来先去找Controller，看能不能找到，不能处理的所有请求都交给静态资源处理器，都找不到的话返回404.</p><p>自定义静态资源目录：</p><span id="more"></span><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="attr">static-locations:</span> [<span class="string">classpath:/abc/</span>]</span><br><span class="line"><span class="comment">#[key:value]不能有空格</span></span><br></pre></td></tr></table></figure><h3 id="静态资源访问前缀"><a href="#静态资源访问前缀" class="headerlink" title="静态资源访问前缀"></a>静态资源访问前缀</h3><p>默认无前缀，为方便以后用到拦截器，可以指定静态资源访问前缀，使拦截器放行：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br></pre></td></tr></table></figure><p>访问：当前项目+static-path-pattern+静态资源名</p><h2 id="欢迎页支持"><a href="#欢迎页支持" class="headerlink" title="欢迎页支持"></a>欢迎页支持</h2><h3 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h3><p><strong>静态资源路径下 index.html</strong></p><p>​    可以配置静态资源路径</p><p>​    不可以配置访问前缀，否则无法访问。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment"># mvc:</span></span><br><span class="line">    <span class="comment">#   static-path-pattern: /res/**</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line"><span class="attr">static-locations:</span> [<span class="string">classpath:/abc/</span>]</span><br></pre></td></tr></table></figure><p><strong>controller处理/index</strong></p><h3 id="自定义Favicon"><a href="#自定义Favicon" class="headerlink" title="自定义Favicon"></a>自定义Favicon</h3><p>favicon.ico放在静态资源目录下即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment"># mvc:</span></span><br><span class="line">    <span class="comment">#   static-path-pattern: /res/**  这个配置会导致Favicon功能失效</span></span><br></pre></td></tr></table></figure><h2 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a>请求参数处理</h2><h3 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h3><p><strong>@xxxMapping</strong></p><p><strong>Rest风格支持</strong>（使用http请求方式动词来表示对资源的操作）</p><p>/user   </p><pre><code> GET-获取用户   DELETE-删除用户    PUT-修改用户   POST-保存用户</code></pre><p>核心Filter：HiddenHttpMethodFilter</p><p>​    用法：表单method=post ， 隐藏域_method=put</p><p>​    springboot中手动开启</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">mvc:</span></span><br><span class="line">       <span class="attr">hiddenmethod:</span></span><br><span class="line">         <span class="attr">filter:</span></span><br><span class="line">           <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment">#开启页面表单的Rest</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;GET&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span>  <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span>  <span class="attr">value</span>=<span class="string">&quot;DELETE&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;DELETE&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    DELETE和PUT提交方式都为post，value值大小写都行，这是底层配置决定的</p><p><strong>请求过来被HiddenHttpMethodFilter拦截</strong></p><p>​    请求是否正常，并且是POST</p><p>​        获取到_method的值</p><p>​        兼容以下请求：PUT,DELETE,PATCH</p><p>​        原生request（post），包装模式requestWrapper重写了getMethod方法，返回的是传入的值</p><p>​        过滤器链放行的时候用wrapper，以后的方法调用getMethod是调用requestWrapper的</p><p><strong>Rest使用客户端工具</strong></p><p>​    如PostMan直接发送put,delete请求，无需filter</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简单功能分析&quot;&gt;&lt;a href=&quot;#简单功能分析&quot; class=&quot;headerlink&quot; title=&quot;简单功能分析&quot;&gt;&lt;/a&gt;简单功能分析&lt;/h1&gt;&lt;h2 id=&quot;静态资源访问&quot;&gt;&lt;a href=&quot;#静态资源访问&quot; class=&quot;headerlink&quot; title=&quot;静态资源访问&quot;&gt;&lt;/a&gt;静态资源访问&lt;/h2&gt;&lt;h3 id=&quot;静态资源目录&quot;&gt;&lt;a href=&quot;#静态资源目录&quot; class=&quot;headerlink&quot; title=&quot;静态资源目录&quot;&gt;&lt;/a&gt;静态资源目录&lt;/h3&gt;&lt;p&gt;只要静态资源放在类路径下：called &lt;strong&gt;/static&lt;/strong&gt;(or &lt;strong&gt;/public&lt;/strong&gt; or &lt;strong&gt;/META-INF/resources&lt;/strong&gt; or &lt;strong&gt;/resources&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;访问：当前项目根路径/+静态资源名&lt;/p&gt;
&lt;p&gt;原理：静态映射/**，请求进来先去找Controller，看能不能找到，不能处理的所有请求都交给静态资源处理器，都找不到的话返回404.&lt;/p&gt;
&lt;p&gt;自定义静态资源目录：&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="http://wyfboy.github.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://wyfboy.github.io/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
