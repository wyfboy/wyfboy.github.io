<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AOP与OOP的比较</title>
    <url>/2021/03/27/AOP/</url>
    <content><![CDATA[<h2 id="AOP面向切面，为什么要面向切面？哪些操作需要AOP编程？"><a href="#AOP面向切面，为什么要面向切面？哪些操作需要AOP编程？" class="headerlink" title="AOP面向切面，为什么要面向切面？哪些操作需要AOP编程？"></a>AOP面向切面，为什么要面向切面？哪些操作需要AOP编程？</h2><p>​        Aop主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合的隔离效果。</p>
<span id="more"></span>

<p>​        比如我们最常见的就是日志记录了，举个例子，我们现在提供一个查询学生信息的服务，但是我们希望记录有谁进行了这个查询。如果按照传统的OOP的实现的话，那我们实现了一个查询学生信息的服务接口(StudentInfoService)和其实现 类 （StudentInfoServiceImpl.java），同时为了要进行记录的话，那我们在实现类(StudentInfoServiceImpl.java)中要添加其实现记录的过程<br>​        当要实现的服务有多个时，那就要在每个实现类都添加这些记录过程，这就非常繁琐，而且每个实现类都与记录服务日志的行为紧耦合，违反了面向对象的规则。</p>
<p><strong>一般oop模式：</strong></p>
<p><img data-src="oop.png"></p>
<p>每一个模块都跟日志、事务这些功能交织在一起，无法分离，每当修改日志的形式的时候，需要非常多的代码。</p>
<p><strong>aop模式：</strong></p>
<p>​                                                           <img data-src="aop.png"></p>
<p>输入的数据先经过日志、事务等控制模块，然后再流向实际的业务模块，而日志、事务这些控制模块看起来就像一道切面，切在数据流的中间</p>
<p><strong>优势：</strong></p>
<ol>
<li>解耦</li>
<li>重复利用代码</li>
<li>便于装卸</li>
</ol>
<h2 id="Configuration使用示例"><a href="#Configuration使用示例" class="headerlink" title="Configuration使用示例"></a>Configuration使用示例</h2><p>1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的</p>
<p>2、配置类本身也是组件</p>
<p>3、proxyBeanMethods：代理bean的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Full(proxyBeanMethods = <span class="keyword">true</span>)、【保证每个<span class="meta">@Bean</span>方法被调用多少次返回的组件都是单实例的】</span><br><span class="line">Lite(proxyBeanMethods = <span class="keyword">false</span>)【每个<span class="meta">@Bean</span>方法被调用多少次返回的组件都是新创建的】</span><br></pre></td></tr></table></figure>

<p><strong>组件依赖必须使用Full模式默认。其他默认是否Lite模式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">   User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">   <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">   zhangsan.setPet(tomcatPet());</span><br><span class="line">   <span class="keyword">return</span> zhangsan;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;tom&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>@Configuration测试代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">相当于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">    String[] names = run.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、从容器中获取组件</span></span><br><span class="line"></span><br><span class="line">    Pet tom01 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">    Pet tom02 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;组件：&quot;</span>+(tom01 == tom02));</span><br><span class="line">    <span class="comment">//4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892</span></span><br><span class="line">    MyConfig bean = run.getBean(MyConfig.class);</span><br><span class="line">    System.out.println(bean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。</span></span><br><span class="line">    <span class="comment">//保持组件单实例</span></span><br><span class="line">    User user = bean.user01();</span><br><span class="line">    User user1 = bean.user01();</span><br><span class="line">    System.out.println(user == user1);</span><br><span class="line">    User user01 = run.getBean(<span class="string">&quot;user01&quot;</span>, User.class);</span><br><span class="line">    Pet tom = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;用户的宠物：&quot;</span>+(user01.getPet() == tom));</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Configuration注解用法</title>
    <url>/2021/03/27/Configuration%E6%B3%A8%E8%A7%A3%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Configuration使用示例"><a href="#Configuration使用示例" class="headerlink" title="Configuration使用示例"></a>Configuration使用示例</h2><p>1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的</p>
<p>2、配置类本身也是组件</p>
<p>3、proxyBeanMethods：代理bean的方法</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Full(proxyBeanMethods = <span class="keyword">true</span>)、【保证每个<span class="meta">@Bean</span>方法被调用多少次返回的组件都是单实例的】</span><br><span class="line">Lite(proxyBeanMethods = <span class="keyword">false</span>)【每个<span class="meta">@Bean</span>方法被调用多少次返回的组件都是新创建的】</span><br></pre></td></tr></table></figure>

<p><strong>组件依赖必须使用Full模式默认。其他默认是否Lite模式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">   User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">   <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">   zhangsan.setPet(tomcatPet());</span><br><span class="line">   <span class="keyword">return</span> zhangsan;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;tom&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>@Configuration测试代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">相当于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">    String[] names = run.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、从容器中获取组件</span></span><br><span class="line"></span><br><span class="line">    Pet tom01 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">    Pet tom02 = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;组件：&quot;</span>+(tom01 == tom02));</span><br><span class="line">    <span class="comment">//4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892</span></span><br><span class="line">    MyConfig bean = run.getBean(MyConfig.class);</span><br><span class="line">    System.out.println(bean);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。</span></span><br><span class="line">    <span class="comment">//保持组件单实例</span></span><br><span class="line">    User user = bean.user01();</span><br><span class="line">    User user1 = bean.user01();</span><br><span class="line">    System.out.println(user == user1);</span><br><span class="line">    User user01 = run.getBean(<span class="string">&quot;user01&quot;</span>, User.class);</span><br><span class="line">    Pet tom = run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;用户的宠物：&quot;</span>+(user01.getPet() == tom));</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记</title>
    <url>/2021/03/23/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="简单功能分析"><a href="#简单功能分析" class="headerlink" title="简单功能分析"></a>简单功能分析</h1><h2 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h2><h3 id="静态资源目录"><a href="#静态资源目录" class="headerlink" title="静态资源目录"></a>静态资源目录</h3><p>只要静态资源放在类路径下：called <strong>/static</strong>(or <strong>/public</strong> or <strong>/META-INF/resources</strong> or <strong>/resources</strong>)</p>
<p>访问：当前项目根路径/+静态资源名</p>
<p>原理：静态映射/**，请求进来先去找Controller，看能不能找到，不能处理的所有请求都交给静态资源处理器，都找不到的话返回404.</p>
<p>自定义静态资源目录：</p>
<span id="more"></span>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">resources:</span></span><br><span class="line">		<span class="attr">static-locations:</span> [<span class="string">classpath:/abc/</span>]</span><br><span class="line"><span class="comment">#[key:value]不能有空格</span></span><br></pre></td></tr></table></figure>



<h3 id="静态资源访问前缀"><a href="#静态资源访问前缀" class="headerlink" title="静态资源访问前缀"></a>静态资源访问前缀</h3><p>默认无前缀，为方便以后用到拦截器，可以指定静态资源访问前缀，使拦截器放行：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">mvc:</span></span><br><span class="line">    	<span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br></pre></td></tr></table></figure>

<p>访问：当前项目+static-path-pattern+静态资源名</p>
<h2 id="欢迎页支持"><a href="#欢迎页支持" class="headerlink" title="欢迎页支持"></a>欢迎页支持</h2><h3 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h3><p><strong>静态资源路径下 index.html</strong></p>
<p>​    可以配置静态资源路径</p>
<p>​    不可以配置访问前缀，否则无法访问。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="comment"># mvc:</span></span><br><span class="line">    <span class="comment">#   static-path-pattern: /res/**</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">		<span class="attr">static-locations:</span> [<span class="string">classpath:/abc/</span>]</span><br></pre></td></tr></table></figure>

<p><strong>controller处理/index</strong></p>
<h3 id="自定义Favicon"><a href="#自定义Favicon" class="headerlink" title="自定义Favicon"></a>自定义Favicon</h3><p>favicon.ico放在静态资源目录下即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="comment"># mvc:</span></span><br><span class="line">    <span class="comment">#   static-path-pattern: /res/**  这个配置会导致Favicon功能失效</span></span><br></pre></td></tr></table></figure>

<h2 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a>请求参数处理</h2><h3 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h3><p><strong>@xxxMapping</strong></p>
<p><strong>Rest风格支持</strong>（使用http请求方式动词来表示对资源的操作）</p>
<p>/user   </p>
<pre><code> GET-获取用户   DELETE-删除用户    PUT-修改用户   POST-保存用户
</code></pre>
<p>核心Filter：HiddenHttpMethodFilter</p>
<p>​    用法：表单method=post ， 隐藏域_method=put</p>
<p>​    springboot中手动开启</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">mvc:</span></span><br><span class="line">       <span class="attr">hiddenmethod:</span></span><br><span class="line">         <span class="attr">filter:</span></span><br><span class="line">           <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment">#开启页面表单的Rest</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;GET&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span>  <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span>  <span class="attr">value</span>=<span class="string">&quot;DELETE&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;DELETE&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    DELETE和PUT提交方式都为post，value值大小写都行，这是底层配置决定的</p>
<p><strong>请求过来被HiddenHttpMethodFilter拦截</strong></p>
<p>​    请求是否正常，并且是POST</p>
<p>​        获取到_method的值</p>
<p>​        兼容以下请求：PUT,DELETE,PATCH</p>
<p>​        原生request（post），包装模式requestWrapper重写了getMethod方法，返回的是传入的值</p>
<p>​        过滤器链放行的时候用wrapper，以后的方法调用getMethod是调用requestWrapper的</p>
<p><strong>Rest使用客户端工具</strong></p>
<p>​    如PostMan直接发送put,delete请求，无需filter</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>github-hexo图片无法显示</title>
    <url>/2021/04/01/github-hexo%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="config-yml文件修改"><a href="#config-yml文件修改" class="headerlink" title="config.yml文件修改"></a>config.yml文件修改</h3><p>将 <code>post_asset_folder: false</code> 修改为 <code>post_asset_folder: true</code></p>
<p>在新建博文时可以同时在_posts文件夹中创建一个同名文件夹，可以用来存放这个.md博文的图片，易于管理。</p>
<h3 id="Typora偏好设置"><a href="#Typora偏好设置" class="headerlink" title="Typora偏好设置"></a>Typora偏好设置</h3><img data-src="/2021/04/01/github-hexo%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/Typora%E5%81%8F%E5%A5%BD%E8%AE%BE%E7%BD%AE.png" class>

<p>插入同名文件夹里的图片可以看到路径是相对路径：</p>
<img data-src="/2021/04/01/github-hexo%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/%E8%B7%AF%E5%BE%84%E6%98%BE%E7%A4%BA.png" class>

<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p><strong>方式一</strong>：<code>npm install https://github.com/7ym0n/hexo-asset-image --save</code>不幸的是我安装后出现了问题。</p>
<p><strong>另一种迂回方式</strong>：把此文件夹<em>\node_modules\hexo-asset-image</em>删除后，换种方式安装<code>   npm install https://github.com/CodeFalling/hexo-asset-image --save</code>，然后把该插件文件夹里的<em>index.js</em>替换成如下：</p>
<pre><code>&#39;use strict&#39;;
var cheerio = require(&#39;cheerio&#39;);

// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string
function getPosition(str, m, i) &#123;
return str.split(m, i).join(m).length;
&#125;

var version = String(hexo.version).split(&#39;.&#39;);
hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;
var config = hexo.config;
if(config.post_asset_folder)&#123;
    var link = data.permalink;
if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)
    var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;
else
    var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;
// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.
var endPos = link.lastIndexOf(&#39;/&#39;) + 1;
link = link.substring(beginPos, endPos);

var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];
for(var i = 0; i &lt; toprocess.length; i++)&#123;
    var key = toprocess[i];
var $ = cheerio.load(data[key], &#123;
ignoreWhitespace: false,
xmlMode: false,
lowerCaseTags: false,
decodeEntities: false
&#125;);

$(&#39;img&#39;).each(function()&#123;
if ($(this).attr(&#39;src&#39;))&#123;
    // For windows style path, we replace &#39;\&#39; to &#39;/&#39;.
    var src = $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;/&#39;);
    if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;
        !/^\s*\//.test(src)) &#123;
        // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.
        // In addition, to support multi-level local directory.
        var linkArray = link.split(&#39;/&#39;).filter(function(elem)&#123;
        return elem != &#39;&#39;;
        &#125;);
        var srcArray = src.split(&#39;/&#39;).filter(function(elem)&#123;
        return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;
        &#125;);
        if(srcArray.length &gt; 1)
        srcArray.shift();
        src = srcArray.join(&#39;/&#39;);
        $(this).attr(&#39;src&#39;, config.root + link + src);
        console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);
    &#125;
&#125;else&#123;
    console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);
    console.info&amp;&amp;console.info($(this));
&#125;
&#125;);
data[key] = $.html();
&#125;
&#125;
&#125;);
</code></pre>
<p>再次生成和部署后，成功显示图片。（本地预览和部署到github上后都能正常显示）</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo图片无法显示</tag>
      </tags>
  </entry>
</search>
